# -*- coding: utf-8 -*-
"""b2.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1AiIz8LDAzCBNbMY2vX1AJpaSxwcRpva1
"""

import functools as ft
import matplotlib.pyplot as plt
import random 
from random import randint
from operator import add

#Selecting random points and storing them in a list X
random.seed(42)
H_large_minus = random.sample(range(-1000,10), 50)
H_large_plus = random.sample(range(10,1000), 50)
H_small = random.sample(range(-100, 100), 100)
X=[]
for h in H_large_minus:
  X.append(h/10)
for h in H_large_plus:
  X.append(h/10)
for h in H_small:
  X.append(h/100)
random.shuffle(X)
print(X)
#calculating Y points
Y=[]
for x in X:
  Y.append(25*(x**5)+18*(x**4)+31*(x**3)-14*(x**2)+7*x-19)
print(Y)
plt.scatter(X,Y)
plt.show()

def individual():
  #returns 6 random parameters at powers of x
   return [ randint(-50,50) for x in range(6) ] 
def population(count=1000,pop=[0]):
  if pop==[0]:
    return [ individual() for n in range(count) ]
  else:
    return pop
 #target is one of n points,i.e respective y value
def fitness(individual, y_real, x_real):
  y_generated=0
  i=0
  for ind in individual :
    y_generated += ind * (x_real**i)
    i+=1
  return abs((y_real-y_generated)/y_real) # relative error
def grade(pop, target,x_real):
  summed=0
  for p in pop:
    summed += fitness(p, target,x_real)
  return summed/len(pop)
def evolve(pop, target,x_real, retain=0.3, random_select=0.03, mutate=0.02):
    graded = [ (fitness(x, target,x_real), x) for x in pop]
    graded = [ x[1] for x in sorted(graded)]
    retain_length =  int(len(graded)*retain)
    parents = graded[:retain_length]
    for individual in graded[retain_length:]:
      if random_select > random.random():
        parents.append(individual)
    for individual in parents:
      if mutate > random.random():
        pos_to_mutate = random.randint(0, len(individual)-1)
        individual[pos_to_mutate] = randint(min(individual),max(individual))
    parents_length = len(parents)
    desired_length = len(pop)- parents_length
    children = []
    while len(children) < desired_length :
      male = random.randint(0, parents_length-1)
      female = random.randint(0, parents_length-1)
      if male != female :
        male=parents[male]
        female=parents[female]
        half = (len(male)/2)
        child = male[:int(half)] + female[int(half):]
        children.append(child)
    parents.extend(children)
    return(parents)

target = Y
x_real=X
k=0
j=0
generations = 30
p = population(1000)
fitness_history = [grade( p, target[0],x_real[0]) , ]
colours = []
# colours for coefficients' evolution
for i in range(len(x_real)):
  colours.append('#%06X' % randint(0, 0xFFFFFA))
# evolutin block
for i in range(generations):
  if fitness_history[-1]<0.005:
    break
  for k in range(len(x_real)):
     p = evolve( p , target[k],x_real[k] )
     fitness_history.append(grade( p , target[k],x_real[k] ) )
     for t in range(-5,5,1):
       j=0
       y_gen=0
       for w in p[3]:
         y_gen+=w*(t**j)
         j+=1
       c=colours[k]
       plt.scatter(t,y_gen,color=c)
plt.show()

for t in range(-100,100,10):
    j=0
    y_gen=0
    for w in p[42]:
      y_gen+=w*(t**j)
      j+=1
    c=colours[k]
    plt.scatter(t,y_gen,s=20,color="red",marker='s')
plt.scatter(X,Y,s=5,color="black",alpha=0.5)
plt.show()

plt.plot(fitness_history)
plt.grid()
plt.ylabel('average fitness in population')
plt.xlabel('generations')
print(fitness_history[-1])
import numpy
coefficients=numpy.array([0,0,0,0,0,0])
for q in p:
  coefficients+=numpy.array(q)

print(coefficients/len(p))